#!/usr/bin/env python

import argparse, sys, csv

def main():

    # Parse arguments.
    parser = argparse.ArgumentParser(description='takes in SAM format input generated by BWA aligner and filters reads by edit distance. Outputs to STDOUT.')
    parser.add_argument('-i', '--input', nargs='?', type=argparse.FileType('r'), default=sys.stdin, help='indicate input.sam (leave out if using STDIN).')
    parser.add_argument('-n', '--nedit', help='indicate max edit distance allowed per read (default=10)', default=10, type=int, required=False)
    parser.add_argument('-f', '--format', help='indicate bwa algorithm used. options: mem, sampe', default="sampe", type=str, required=False)
    args = parser.parse_args()

    SAMin = csv.reader(args.input, delimiter = '\t', quoting=csv.QUOTE_NONE)

    if "mem" in args.format:
        nmfield = 11
    elif "sampe" in args.format:
        nmfield = 12

    for row in SAMin:
        try:
            if '@' in row[0] or int(row[nmfield].strip("NM:i:")) <= args.nedit:
                print('\t'.join(row))
        except IndexError:
            try:
                if row[5] == '*': # two distinct classes of mate unmapped read records are possible that register as failed read (asterisk) in CIGAR field (col 6) and result empty string in TAG field (col >12): (1) reads whose mates truly failed to map and (2) multimapping reads whose mates are in fact mapped but in a proper pair that excludes the particular read record. Each of these two classes of mate unmapped reads can contain multimapping reads that map to two or more locations. These are retained in the output.
                    print('\t'.join(row))
            except IndexError:
                pass
        except ValueError:
            print('\t'.join(row))

if __name__ == '__main__':
    main()
